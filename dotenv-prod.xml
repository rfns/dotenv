<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="DotEnv.Command">
<Description>
testeasege</Description>
<IncludeCode>%occOptions,%occStatus</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64590,33223.656877</TimeCreated>

<Property name="ErrorFilePath">
<Type>%String</Type>
</Property>

<Property name="OutputFilePath">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..ErrorFilePath = ##class(%File).TempFilename()
  set ..OutputFilePath = ##class(%File).TempFilename()
  quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set sc = $$$ADDSC(sc, ##class(%File).Delete(..ErrorFilePath))
  set sc = $$$ADDSC(sc, ##class(%File).Delete(..OutputFilePath))
  quit sc
]]></Implementation>
</Method>

<Method name="CaptureEnvsFromHostOS">
<Internal>1</Internal>
<FormalSpec>*outputBuffer:%Stream.Object=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set commmandString = ""

  if $$$isWINDOWS {
    set commmandString = $$$FormatText("set 2> ""%1"" > ""%2""", ..ErrorFilePath, ..OutputFilePath)
  } elseif $$$isUNIX {
    set commmandString = $$$FormatText("printenv 2> ""%1"" > ""%2""", ..ErrorFilePath, ..OutputFilePath)
  }

  do $zf(-1, commmandString)

  set outputBuffer = ##class(%FileCharacterStream).%New()
  set outputBuffer.Filename = ..OutputFilePath

  set errorBuffer = ##class(%FileCharacterStream).%New()
  set errorBuffer.Filename = ..ErrorFilePath

  if outputBuffer.Size = 0 quit $$$ERROR(5001, "Unable to execute OS command, failed due to: "_errorBuffer.Read())

  quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="DotEnv.Parser">
<Abstract>1</Abstract>
<IncludeCode>%occStatus</IncludeCode>
<TimeCreated>64590,42909.031919</TimeCreated>

<Method name="FromOS">
<ClassMethod>1</ClassMethod>
<FormalSpec>*sc:%Status=$$$OK</FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
  set command = ##class(DotEnv.Command).%New()
  set sc = command.CaptureEnvsFromHostOS(.output)
  quit ..CreateArray(output)
]]></Implementation>
</Method>

<Method name="FromPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String,*sc:%Status=$$$OK,dotenv:%String=".env"</FormalSpec>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
  #dim dotEnvs, envs As %ArrayOfDataTypes

  set envs = ..FromOS(.sc)
  if $$$ISERR(sc) return envs
  set fs = ##class(%Stream.FileCharacter).%New()
  set sc = fs.LinkToFile(path_"//"_dotenv)
  set dotEnvs = ..CreateArray(fs)
  set envName = ""

  for i=1:1:dotEnvs.Count() {
    set envName = dotEnvs.Next(envName)
    set envValue = dotEnvs.GetAt(envName)

    if 'envs.IsDefined(envName) {
      set sc = envs.SetAt(envValue, envName)
      if $$$ISERR(sc) quit
    }
  }
  quit envs
]]></Implementation>
</Method>

<Method name="CreateArray">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>out:%Stream.Object</FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
  set envs = ##class(%ArrayOfDataTypes).%New()
  if '$isobject(out) quit envs

  while 'out.AtEnd {
    set line = out.ReadLine()
    continue:line=""
    set envName = $piece(line, "=")
    set envValue = $piece(line, "=", 2)
    if $extract(envValue) = $char(34) && ($extract(envValue, *) = $char(34)) {
      set envValue = $zconvert($extract(envValue, 2, *-1), "I", "JS")
    }
    do envs.SetAt(envValue, envName)
  }
  quit envs
]]></Implementation>
</Method>
</Class>
</Export>
